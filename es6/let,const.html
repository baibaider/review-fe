<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>es6 let&const</title>
    <style type="text/css">
      p{
        color: #c685d9;
      }
      .const{
        background-color: #ccc;
      }
      .let{
        background-color: rgba(3, 237, 252, 0.25);
      }
      .window{
        background-color: rgba(42, 23, 159, 0.22);
      }
    </style>
  </head>
  <body>
    <div class="const">
      <p>const 命令基本用法</p>
      <p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
      <p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
      <p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
      <p>const声明的常量，也与let一样不可重复声明</p>
      <p style="color:#fff">const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。</p>
    </div>
    <div class="let">
      <p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
      <p>for循环的计数器，就很合适使用let命令。</p>
        <p>var a = [];
      for (var i = 0; i < 10; i++) {
      a[i] = function () {
      console.log(i);
    };
  }
  a[6](); // 10</p>
  <p>let不允许在相同作用域内，重复声明同一个变量</p>
    </div>
    <div class="window">
      ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

  var a = 1;
  // 如果在 Node 的 REPL 环境，可以写成 global.a
  // 或者采用通用方法，写成 this.a
  window.a // 1

  let b = 1;
  window.b // undefined
  上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。
    </div>
  </body>
</html>
